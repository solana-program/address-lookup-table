/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    combineCodec,
    getAddressDecoder,
    getAddressEncoder,
    getArrayDecoder,
    getArrayEncoder,
    getStructDecoder,
    getStructEncoder,
    getU32Decoder,
    getU32Encoder,
    getU64Decoder,
    getU64Encoder,
    transformEncoder,
    type AccountMeta,
    type AccountSignerMeta,
    type Address,
    type Codec,
    type Decoder,
    type Encoder,
    type Instruction,
    type InstructionWithAccounts,
    type InstructionWithData,
    type ReadonlyAccount,
    type ReadonlySignerAccount,
    type ReadonlyUint8Array,
    type TransactionSigner,
    type WritableAccount,
    type WritableSignerAccount,
} from '@solana/kit';
import { resolveExtendLookupTableBytes } from '../../hooked';
import { ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type InstructionWithByteDelta, type ResolvedAccount } from '../shared';

export const EXTEND_LOOKUP_TABLE_DISCRIMINATOR = 2;

export function getExtendLookupTableDiscriminatorBytes() {
    return getU32Encoder().encode(EXTEND_LOOKUP_TABLE_DISCRIMINATOR);
}

export type ExtendLookupTableInstruction<
    TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,
    TAccountAddress extends string | AccountMeta<string> = string,
    TAccountAuthority extends string | AccountMeta<string> = string,
    TAccountPayer extends string | AccountMeta<string> = string,
    TAccountSystemProgram extends string | AccountMeta<string> = '11111111111111111111111111111111',
    TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
    InstructionWithData<ReadonlyUint8Array> &
    InstructionWithAccounts<
        [
            TAccountAddress extends string ? WritableAccount<TAccountAddress> : TAccountAddress,
            TAccountAuthority extends string
                ? ReadonlySignerAccount<TAccountAuthority> & AccountSignerMeta<TAccountAuthority>
                : TAccountAuthority,
            TAccountPayer extends string
                ? WritableSignerAccount<TAccountPayer> & AccountSignerMeta<TAccountPayer>
                : TAccountPayer,
            TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram,
            ...TRemainingAccounts,
        ]
    >;

export type ExtendLookupTableInstructionData = {
    discriminator: number;
    addresses: Array<Address>;
};

export type ExtendLookupTableInstructionDataArgs = {
    addresses: Array<Address>;
};

export function getExtendLookupTableInstructionDataEncoder(): Encoder<ExtendLookupTableInstructionDataArgs> {
    return transformEncoder(
        getStructEncoder([
            ['discriminator', getU32Encoder()],
            ['addresses', getArrayEncoder(getAddressEncoder(), { size: getU64Encoder() })],
        ]),
        value => ({ ...value, discriminator: EXTEND_LOOKUP_TABLE_DISCRIMINATOR }),
    );
}

export function getExtendLookupTableInstructionDataDecoder(): Decoder<ExtendLookupTableInstructionData> {
    return getStructDecoder([
        ['discriminator', getU32Decoder()],
        ['addresses', getArrayDecoder(getAddressDecoder(), { size: getU64Decoder() })],
    ]);
}

export function getExtendLookupTableInstructionDataCodec(): Codec<
    ExtendLookupTableInstructionDataArgs,
    ExtendLookupTableInstructionData
> {
    return combineCodec(getExtendLookupTableInstructionDataEncoder(), getExtendLookupTableInstructionDataDecoder());
}

export type ExtendLookupTableInput<
    TAccountAddress extends string = string,
    TAccountAuthority extends string = string,
    TAccountPayer extends string = string,
    TAccountSystemProgram extends string = string,
> = {
    address: Address<TAccountAddress>;
    authority: TransactionSigner<TAccountAuthority>;
    payer: TransactionSigner<TAccountPayer>;
    systemProgram?: Address<TAccountSystemProgram>;
    addresses: ExtendLookupTableInstructionDataArgs['addresses'];
};

export function getExtendLookupTableInstruction<
    TAccountAddress extends string,
    TAccountAuthority extends string,
    TAccountPayer extends string,
    TAccountSystemProgram extends string,
    TProgramAddress extends Address = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,
>(
    input: ExtendLookupTableInput<TAccountAddress, TAccountAuthority, TAccountPayer, TAccountSystemProgram>,
    config?: { programAddress?: TProgramAddress },
): ExtendLookupTableInstruction<
    TProgramAddress,
    TAccountAddress,
    TAccountAuthority,
    TAccountPayer,
    TAccountSystemProgram
> &
    InstructionWithByteDelta {
    // Program address.
    const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        address: { value: input.address ?? null, isWritable: true },
        authority: { value: input.authority ?? null, isWritable: false },
        payer: { value: input.payer ?? null, isWritable: true },
        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;

    // Original args.
    const args = { ...input };

    // Resolver scope.
    const resolverScope = { programAddress, accounts, args };

    // Resolve default values.
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
    }

    // Bytes created or reallocated by the instruction.
    const byteDelta: number = [resolveExtendLookupTableBytes(resolverScope)].reduce((a, b) => a + b, 0);

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    return Object.freeze({
        accounts: [
            getAccountMeta(accounts.address),
            getAccountMeta(accounts.authority),
            getAccountMeta(accounts.payer),
            getAccountMeta(accounts.systemProgram),
        ],
        byteDelta,
        data: getExtendLookupTableInstructionDataEncoder().encode(args as ExtendLookupTableInstructionDataArgs),
        programAddress,
    } as ExtendLookupTableInstruction<
        TProgramAddress,
        TAccountAddress,
        TAccountAuthority,
        TAccountPayer,
        TAccountSystemProgram
    > &
        InstructionWithByteDelta);
}

export type ParsedExtendLookupTableInstruction<
    TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,
    TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
    programAddress: Address<TProgram>;
    accounts: {
        address: TAccountMetas[0];
        authority: TAccountMetas[1];
        payer: TAccountMetas[2];
        systemProgram: TAccountMetas[3];
    };
    data: ExtendLookupTableInstructionData;
};

export function parseExtendLookupTableInstruction<
    TProgram extends string,
    TAccountMetas extends readonly AccountMeta[],
>(
    instruction: Instruction<TProgram> &
        InstructionWithAccounts<TAccountMetas> &
        InstructionWithData<ReadonlyUint8Array>,
): ParsedExtendLookupTableInstruction<TProgram, TAccountMetas> {
    if (instruction.accounts.length < 4) {
        // TODO: Coded error.
        throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            address: getNextAccount(),
            authority: getNextAccount(),
            payer: getNextAccount(),
            systemProgram: getNextAccount(),
        },
        data: getExtendLookupTableInstructionDataDecoder().decode(instruction.data),
    };
}
